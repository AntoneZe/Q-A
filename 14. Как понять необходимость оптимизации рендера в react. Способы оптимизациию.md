**Как понять необходимость оптимизации рендера в react. Способы оптимизации**

- Анализ производительности компонентов с помощью инструмента разработки «Profiler»

Пакеты react-dom версии 16.5+ и react-native версии 0.57+ предоставляют расширенные возможности анализа производительности в режиме разработки с помощью инструментов разработчика React Profiler. Обзор профайлера можно найти в посте блога «Введение в React Profiler». Пошаговое видео-руководство также доступно на YouTube.

Если вы ещё не установили инструменты разработчика React, вы можете найти их здесь:

Chrome Browser Extension
Firefox Browser Extension
Standalone Node Package

- Виртуализация длинных списков

Если ваше приложение рендерит длинные списки данных (сотни или тысячи строк), мы рекомендуем использовать метод известный как «оконный доступ». Этот метод рендерит только небольшое подмножество строк в данный момент времени и может значительно сократить время, необходимое для повторного рендера компонентов, а также количество создаваемых DOM-узлов.

react-window и react-virtualized — это популярные библиотеки для оконного доступа. Они предоставляют несколько повторно используемых компонентов для отображения списков, сеток и табличных данных. Если вы хотите использовать что-то более специфическое для вашего конкретного случая, то вы можете создать собственный компонент с оконным доступом, как это сделано в Twitter.

- Избежание согласования

React создаёт и поддерживает внутреннее представление отображаемого пользовательского интерфейса. Оно также включает React-элементы возвращаемые из ваших компонентов. Это представление позволяет React избегать создания DOM-узлов и не обращаться к текущим без необходимости, поскольку эти операции могут быть медленнее, чем операции с JavaScript-объектами. Иногда его называют «виртуальный DOM», но в React Native это работает точно так же.

Когда изменяются пропсы или состояние компонента, React решает нужно ли обновление DOM, сравнивая возвращённый элемент с ранее отрендеренным. Если они не равны, React обновит DOM.

Несмотря на то, что React обновляет только изменённые DOM-узлы, повторный рендеринг всё же занимает некоторое время. В большинстве случаев это не проблема, но если замедление заметно, то вы можете всё ускорить, переопределив метод жизненного цикла shouldComponentUpdate, который вызывается перед началом процесса ререндеринга. Реализация этой функции по умолчанию возвращает true, указывая React выполнить обновление:

```javaScript
shouldComponentUpdate(nextProps, nextState) {
  return true;
}
```

Если вы знаете ситуации, в которых ваш компонент не нуждается в обновлении, вы можете вернуть false из shouldComponentUpdate, чтобы пропустить весь процесс рендеринга, включая вызов render() и так далее ниже по иерархии.

В большинстве случаев вместо того, чтобы писать shouldComponentUpdate() вручную, вы можете наследоваться от React.PureComponent. Это эквивалентно реализации shouldComponentUpdate() с поверхностным сравнением текущих и предыдущих пропсов и состояния.

- shouldComponentUpdate в действии

Вот поддерево компонентов. Для каждого из них SCU указывает что возвратил shouldComponentUpdate, а vDOMEq указывает эквивалентны ли отрендеренные React элементы. Наконец, цвет круга указывает требуется ли согласовать компонент или нет.

![image info](./14-1.png)

Поскольку shouldComponentUpdate возвратил false для поддерева с корнем C2, React не пытался отрендерить C2, следовательно не нужно вызывать shouldComponentUpdate на C4 и C5.

Для C1 и C3 shouldComponentUpdate возвратил true, поэтому React пришлось спуститься к листьям и проверить их. Для C6 shouldComponentUpdate вернул true, и поскольку отображаемые элементы не были эквивалентны, React должен был обновить DOM.

Последний интересный случай — C8. React должен был отрисовать этот компонент, но поскольку возвращаемые им React-элементы были равны ранее предоставленным, ему не нужно обновлять DOM.

Обратите внимание, что React должен был делать изменения только для C6. Для C8 этого удалось избежать сравнением отрендеренных React-элементов, а для поддеревьев C2 и C7 даже не пришлось сравнивать элементы, так как нас выручил shouldComponentUpdate и render не был вызван.

- **Примеры**

Если единственный случай изменения вашего компонента это когда переменная props.color или state.count изменяются, вы могли бы выполнить проверку в shouldComponentUpdate следующим образом:

class CounterButton extends React.Component {

```javaScript
class CounterButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 1};
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.props.color !== nextProps.color) {
      return true;
    }
    if (this.state.count !== nextState.count) {
      return true;
    }
    return false;
  }

  render() {
    return (
      <button
        color={this.props.color}
        onClick={() => this.setState(state => ({count: state.count + 1}))}>
        Счётчик: {this.state.count}
      </button>
    );
  }
}
```

В этом коде shouldComponentUpdate — это простая проверка на наличие каких-либо изменений в props.color или state.count. Если эти значения не изменяются, то компонент не обновляется. Если ваш компонент стал более сложным, вы можете использовать аналогичный паттерн «поверхностного сравнения» между всеми полями props и state, чтобы определить должен ли обновиться компонент. Этот механизм достаточно распространён, поэтому React предоставляет вспомогательную функцию для работы с ним — просто наследуйтесь от React.PureComponent. Поэтому, следующий код — это более простой способ добиться того же самого эффекта:

```javaScript
class CounterButton extends React.PureComponent {
  constructor(props) {
    super(props);
    this.state = {count: 1};
  }

  render() {
    return (
      <button
        color={this.props.color}
        onClick={() => this.setState(state => ({count: state.count + 1}))}>
        Счётчик: {this.state.count}
      </button>
    );
  }
}
```

В большинстве случаев вы можете использовать React.PureComponent вместо написания собственного shouldComponentUpdate. Но он делает только поверхностное сравнение, поэтому его нельзя использовать, если пропсы и состояние могут измениться таким образом, который не сможет быть обнаружен при поверхностном сравнении.

Это может стать проблемой для более сложных структур данных. Например, вы хотите, чтобы компонент ListOfWords отображал список слов, разделённых через запятую, с родительским компонентом WordAdder, который позволяет кликнуть на кнопку, чтобы добавить слово в список. Этот код работает неправильно:

```javaScript
class ListOfWords extends React.PureComponent {
  render() {
    return <div>{this.props.words.join(',')}</div>;
  }
}

class WordAdder extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      words: ['словцо']
    };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // Данная секция содержит плохой код и приводит к багам
    const words = this.state.words;
    words.push('словцо');
    this.setState({words: words});
  }

  render() {
    return (
      <div>
        <button onClick={this.handleClick} />
        <ListOfWords words={this.state.words} />
      </div>
    );
  }
}
```

Проблема в том, что PureComponent сделает сравнение по ссылке между старыми и новыми значениями this.props.words. Поскольку этот код мутирует массив words в методе handleClick компонента WordAdder, старые и новые значения this.props.words при сравнении по ссылке будут равны, даже если слова в массиве изменились. ListOfWords не будет обновляться, даже если он содержит новые слова, которые должны быть отрендерены.

- **Сила иммутабельных данных**

Лучший способ решения этой проблемы — избегать мутирования значений, которые вы используете как свойства или состояние. К примеру, описанный выше метод handleClick можно переписать с помощью concat следующим образом:

```javaScript
handleClick() {
  this.setState(state => ({
    words: state.words.concat(['словцо'])
  }));
}
```

ES6 поддерживает синтаксис расширения для массивов, который поможет сделать это проще. Если вы используете Create React App, то этот синтаксис доступен там по умолчанию.

```javaScript
handleClick() {
  this.setState(state => ({
    words: [...state.words, 'словцо'],
  }));
};
```

Таким же образом вы можете переписать код, который мутирует объекты. К примеру, мы имеем объект с именем colormap и хотим написать функцию, которая изменяет colormap.right на 'blue'. Мы могли бы написать:

```javaScript
function updateColorMap(colormap) {
  colormap.right = 'blue';
}
```

Чтобы написать это без мутирования исходного объекта, мы можем использовать метод Object.assign:

```javaScript
function updateColorMap(colormap) {
  return Object.assign({}, colormap, {right: 'blue'});
}
```

Функция updateColorMap теперь возвращает новый объект, вместо того, чтобы мутировать исходный. Метод Object.assign входит в ES6 и требует полифила.

Синтаксис расширения свойств объекта упрощает обновление объектов без мутаций:

```javaScript
function updateColorMap(colormap) {
  return {...colormap, right: 'blue'};
}
```

Этот синтаксис был добавлен в JavaScript в ES2018.

Если вы используете Create React App, то Object.assign и синтаксис расширения объектов доступны вам по умолчанию.

При работе с глубоко вложенными объектами, постоянное их обновление может запутать. Если вы столкнулись с такой проблемой, обратите внимание на Immer или immutability-helper. Эти библиотеки позволяют писать хорошо читаемый код, не теряя преимуществ иммутабельности.

**Оптимизация производительности React приложений**

React — хорошо оптимизированная библиотека, “из коробки” гарантирующая высокую производительность. Но любой оптимизации может настать конец, если не правильно подойти к разработке.
Эта статья рассчитана на тех, кто уже начал работать с React, но еще никогда не сталкивался с серьезными проблемами производительности. В ней я расскажу ни столько о способах отладки производительности, а, скорей, о мерах предотвращения таких проблем.

React использует, так называемый, Virtual DOM, основная идея которого — сократить количество обращений к DOM API. Операции с DOM более затратные, чем работа с обычными объектами в Javascript, поэтому React перерисовывает DOM только в том случае, если состояние компонента изменилось.
React имеет иерархическую структуру компонентов. Когда производится обновление старшего компонента, цепочка обновлений начинается распространяться от старших компонентов к потомкам, даже если props этих компонентов не менялись.
Лишь при достижении компонентов, непосредственно связанных с DOM сущностями, производится применение входящих props на Virtual DOM, оценка различий и перерисовка реального DOM.
Сокращайте количество перерисовки DOM
DOM элемент будет перерисован, если хотя бы один ключевой prop, который пришел в его React контроллер, отличается от предыдущего.
Для сравнения старого и нового значения prop используется строгое сравнение, которое, упрощенно говоря, проверяет ссылается ли первая и вторая переменная на одну и ту же область памяти. Понимание этого признака равенства поможет вам лишний раз не обновлять DOM.
Так, например, два объекта, одинаковых по содержанию, но созданных двумя разными вызовами конструктора — не равны. Это тождество справедливо и для функций, массивов и символа.

```javaScript
// Objects
const a = {x: 1};
const b = {x: 1};
a !== b; // Переменные не равны
// Functions
const c = (x) => x + 1;
const d = (x) => x + 1;
c !== d; // Переменные не равны
```

То есть, когда мы говорим об объектах и функциях в Javascript, мы должны помнить, что любой новый объект, функция, массив — это всегда новая область памяти.
А вот две строки, одинаковых по содержанию, но созданные дважды, будут равны, поскольку Javascript оптимизирует хранение в памяти одинаковых строк.

```javaScript
const a = 'Hello, String interning'
const b = 'Hello, String interning'
a === b; // Переменные равны
```

То же самое касается числовых и булевых значений, null и undefined.
Я рассказываю про сравнение различных типов данных, потому что распространенной ошибкой является передача объектов и функций в props компонента, только что созданных в том же стеке, что и сам вызов.

```javaScript
// Анти-паттерн
const MyButtonComponent = () => {
  return <button
    onClick={(e) => console.log('Clicked')}
  />
}
```

В примере выше, каждый вызов MyButtonComponent будет передавать в компонент button новое значение для prop onClick, что в свою очередь будет каждый раз провоцировать обращение к DOM API.
Такой проход не является фатальной ошибкой, и даже допускается в небольших приложениях, но в крупных приложениях или в особых случаях может привести к падению производительности. Поэтому привычку создавать функции и объекты во время рендеринга лучше вообще не заводить.

Передавая в props объект или массив, созданный непосредственно в теле функции, даже если его свойства остаются теми же — это тоже антипаттерн, приводящий к таким же проблемам. Из за того, что конструкторы {} и [] всякий раз создают новый экземпляр объекта, React компонент будет считать, что данные изменились и нужно перерисовывать элемент.


```javaScript
<Select
  options={['A','B','C']}
/>
```

Вместо этого заранее подготавливайте функции-обработчики и сохраняйте их в свойства классов, используйте мемоизацию с хуками (например useCallback) или с компонентами высшего порядка. А объекты кешируйте с помощью useState, useMemo, сохраняйте в свойствах классов или вообще — в корне модуля.
Пример правильного обработчика для onClick в данном случае (с использованием хука):


```javaScript
const MyButtonComponent = () => {
  const clickHandler = React.useCallback(
    (e) => console.log('Clicked')
  );
  return <button
    onClick={clickHandler}
  />
}
```

Хук useCallback гарантирует, что переменная clickHandler всегда будет ссылаться на одну и ту же область памяти.
Сокращайте количество обновлений компонентов
Помимо перерисовки DOM, сами компоненты так же могут содержать тяжелую логику, которая будет выполняется при обновлении. Поэтому логично не обновлять такие компоненты, props для которой не изменились.
По-умолчанию React не предпринимает никаких действий для проверки изменились ли props в пользовательских компонентах, но предлагает коробочный способ для этой проверки: класс React.PureComponent для компонентов-классов и React.memo — для функциональных компонентов.

```javaScript
class MyPureComponent extends React.PureComponent {
  render() {
    // Метод будет вызван только если props компонента изменились
  }
}
```

Но не стоит применять чистые компоненты повсеместно. Нужно понимать, что на сравнение props тоже нужны временные ресурсы и если сделать все компоненты в приложении на базе PureComponent, то это может дать обратный эффект.
Альтернативным способом является использование метода жизненного цикла React shouldComponentUpdate, который позволяет точечно сравнить старые и новые props и на основе этого принять решение о необходимость дальнейшего обновления компонента.

```javaScript
shouldComponentUpdate(nextProps) {
  return nextProps.items !== this.props.items;
}
```

Но я обычно не использую ни PureComponent, ни React.memo, ни shouldComponentUpdate. Вместо этого я вручную сравниваю предыдущие props и новые props в тех частях компонента, где присутствует тяжелая логика, не прерывая жизненный цикл в целом. Это можно делать как в классах, так и с помощью ХОКов, так и с помощью хуков.

```javaScript
withPropsOnChange([`items`], ({
    items
  }) => (
  items: items.map(someWayChangeItem)
));
```


Если вы уверены, что сравнение props будет стоит дешевле, чем холостой прогон всех дочерних компонентов, то используйте вышеуказанные способы. Всегда старайтесь находить компромисс между разными подходами, оценивая их стоимость.
Применяйте виртуализацию для больших списков
Виртуализация — очень старая технология, она была и будет оставаться актуальной всегда, потому что помогает создать иллюзию присутствия на странице очень большого (бесконечного) количества элементов, а фактически содержит только то количество, которое необходимо для их отображения в видимой области.
Когда вы просматриваете веб-сайты, мобильные приложения и, к примеру, листаете ленту новостей или список аудиотреков, возможно, даже не догадываетесь, что вы имеете дело с виртуализацией.
Когда нужна виртуализация? Когда вам нужно отображать массивные списки. К примеру, отобразить на странице миллион элементов. Не трудно догадаться, что попытка рендера миллиона элементов приведет к серьезным проблемам с производительностью:

```javaScript
import React from 'react';
const data = new Array(1000000).fill({name: 'Product'});
function App() {
  return data.map(item => <div>{item.name}</div>);
}
ReactDOM.render(<App />, rootElement);
```

Рендеринг этого кода у меня занял полминуты
Что бы избежать проблем с производительностью при отрисовки миллиона элементов, отображение элементов или необходимо разбить на страницы (применить классический паттерн пейджинации), или использовать виртуализацию.
Механика виртуализации слишком сложна, что бы привести краткий пример ее устройства. В частом случае, виртуализация учитывает количество видимых элементов на странице, и количество элементов, которые могут стать видимыми в ближайшее время. Как только пользователь совершил скролл (или свайп) страницы, элементы которые ушли из зоны видимости (вверх например) сразу же удаляются, а элементы которые должны прийти в зону видимости — создаются.
Более оптимизированным вариантом витуализации является подход, при котором элементы, покинувшие зону видимости, без удаления сразу же используются в качестве приходящих элементов в зону видимости с другой стороны. Таким образом не нужно удалять и создавать DOM узлы, одни и те же DOM узлы просто перемещаются туда сюда.
При виртуализации, несмотря на видимую безграничность скролла, одновременное количество элементов на странице всегда одинаково небольшое.
Этот подход очень похож на технологию в компьютерных играх, называемую Frustum Culling, которая позволяет не отрисовывать те объекты, которые находятся за пределами области видимости игрока. Концепция идентичная — если мы что-то не видим, мы на это не рисуем.
React “под капотом” может автоматически диактивировать компоненты, которые находятся за пределами видимости. Но увы этого функционала не хватает для оптимизации рендеринга массивных списков.
Примером виртуализации из реального мира так же может служить массовка в театре и кино: когда дюжина человек путем быстрого переодевания за кадром и хождением туда сюда создает эффект бесконечного потока пешеходов.
Скорей всего вы будете использовать готовые решения для виртуализации, такие как react-virtualized. Самостоятельная реализация виртуализации не так проста и за нее стоит браться только в особых случаях, когда нету готового решения.
Ищите и лечите тяжелые функции
С тех пор как я (3 года назад) перешел на React (до этого работая на Angular, а еще раньше с jQuery) я почти не встречал серьезных проблем со скоростью рендеринга страниц моих приложений, которые бы потребовали анализа производительности. Если соблюдать основные нормативы грамотности писания кода под React, никаких проблем быть не должно. React — очень хорошо оптимизированный движок.
Но если количество логики и количество повторного использования этой логики в приложении возрастает, уязвимыми для производительности местами в приложении становятся отдельные функции, время на выполнение которых, может быть незначительным при единичном вызове, но заметно снижает производительность при многократном.
К примеру, если какая нибудь вспомогательная функция deepCompare в среднем выполняется за 5ms (что в единичном случае, казалось бы, не так значительно), но эта функция вызывается при рендеринге 200 компонентов на странице, то нужно понимать, что только первичный рендеринг такой страницы увеличится на секунду, что уже недопустимо.
Что бы сократить время рендеринга, в данном случае, вам нужно:

1. Найти эту некую тяжелую функцию;
2. Попытаться оптимизировать эту функцию или заменить ее на что-то другое, более скоростное.

И здесь начинает действовать принцип “копейка рубль бережет”. На практике, в процессе анализа производительности, находится не одна, а множество таких тяжелых или немного тяжелых функций. В особо же сложных ситуациях приходится бороться буквально за каждую долю миллисекунды, находя новые пути оптимизации тех или иных фрагментов кода.
В идеале каждая функция в приложении должна стремиться работать как можно быстрее.
И в поиске таких слабых мест в коде хорошо помогают такие инструменты как Chrome Performance и React Profile. И тот и другой инструмент помогает записать определенный отрывок работы приложения и увидеть сколько времени потребовалось на отработку того или иного фрагмента кода, включая все его вложенные стеки.

Сам процесс анализа очень рутинный и кропотливый, поэтому лишний раз, из соображений профилактики, обычно к нему прибегать не стоит.
Советы по облегчению функций
Прежде чем полагаться на пост-анализ производительности, вот несколько рекомендаций того как можно в принципе заблаговременно избежать появления тяжелых функций:
Используйте иммутабельность
В операциях сравнения два объекта по признаку нахождения в одной области памяти сравниваются в десятки, а то и в сотни раз быстрее, чем через перебор их свойств. Если вы будуте повсеместно применять иммутабельных подход к обновлению состояния, то и все операции сравнения в приложении будут работать многократно быстрее.
По возможности не используйте глубокое сравнение вообще
Функции глубокого (рекурсивного) сравнения объектов в большенство случаев работают крайне медленно. Если в вашем React-приложении возникает необходимость глубокого сравнения объектов, скорей всего что-то не так с вашей архитектурой.
Не выполняйте тяжелые расчеты дважды без необходимости
Если переменные, которые используются в расчетах, не изменились, не нужно производить расчеты второй раз. Используйте shouldComponentUpdate или простое if условие в getDerivedStateFromProps, componentDidUpdate, сравнив старые и новые props:

```javaScript
if (props.a !== prevProps.b) { 
  doSomeHeavyCalculates(props.b);
}
```

Грубо говоря, если само вычисление требует времени на выполнение больше, чем операция сравнения старого и нового значения аргументов для этого вычисления, то нужно сравнивать.
На то что бы сравнить два props нужно, приблизительно, 0.001 ms.
В данном случае вам так же может помочь мемоизация. Кешируйте результаты работы функций. Используйте React.pureComponent, Reselect, Memoize-one, React.memo, хуки useState, useMemo.
Для решения простых задач используйте нативный API
Не используйте слишком универсальные или многофункциональные библиотеки ради решения мелочных задач. Грубо говоря, если вам нужно отформатировать дату в строку “28/11/2019”, то используйте встроенный метод toLocaleDateString:

```javaScript
new Date().toLocaleDateString("ru-RU") // 28/11/2019
```

А не тащите в приложение библиотеку moment.
Не работайте с DOM API напрямую
Помните, что все операции с DOM тяжелые. Не стоит пытаться работать с DOM API напрямую без крайней необходимости. И тем более не пытайтесь использовать jQuery и прочие архаические инструменты в паре с React.
Знайте “цену” методов и операторов Javascript
К примеру:
Метод массива forEach работает быстрее императивного for .. in.
Добавление нового свойства в пустой объект дороже, чем создание нового объекта с этим свойством.
=== строгое сравнение работает быстрее не строгого ==
и т.д.
— и это нужно просто знать.
Используйте продакшен сборку
Собирая приложение для публикации, используйте переменную окружения nodejs NODE_END со значением production.
Многие библиотеки, и React в т.ч., встраивают в свой код различные расширения и хуки, которые облегчают процесс разработки и отладки приложения, но снижают его производительность.
Поскольку эти расширения нужны только для разработки, они и встраиваются только в режиме разработки (когда NODE_ENV !== ‘production’). В режиме продакшен они не поставляются.
Так, например, React в зависимости от режима разработки в целом использует разные входные точки в библиотеку.

```javaScript
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react-is.production.min.js');
} else {
  module.exports = require('./cjs/react-is.development.js');
}
```

Если вы собираете приложение с переменной окружения NODE_ENVв значении production вы заметите повышение его производительности, и одновременно с этим, дополнительные инструменты отладки, такие как React DevTools, станут нерабочими. И наоборот.
Многие популярные бойлерплейты из коробки поддерживают разные режимы сборки в зависимости от назначения. Если вы пишите приложение с нуля, вы сами должны позаботится о выставлении правильного значения переменной окружения NODE_END development — для режима разработки, и production — при публикации.

**useCallback**

```javaScript
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```

Возвращает мемоизированный колбэк.

Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate).

useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).

**useMemo**

```javaScript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

Возвращает мемоизированное значение.

Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo.

Если массив не был передан, новое значение будет вычисляться при каждом рендере.

Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана. Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.

**React.memo**

```javaScript
const MyComponent = React.memo(function MyComponent(props) {
  /* рендер с использованием пропсов */
});
```

React.memo — это компонент высшего порядка.

Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов React.memo для повышения производительности в некоторых случаях, мемоизируя тем самым результат. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга.

React.memo затрагивает только изменения пропсов. Если функциональный компонент обёрнут в React.memo и использует useState, useReducer или useContext, он будет повторно рендериться при изменении состояния или контекста.

По умолчанию он поверхностно сравнивает вложенные объекты в объекте props. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.


```javaScript
function MyComponent(props) {
  /* рендер с использованием пропсов */
}
function areEqual(prevProps, nextProps) {
  /*
  возвращает true, если nextProps рендерит
  тот же результат что и prevProps,
  иначе возвращает false
  */
}
export default React.memo(MyComponent, areEqual);
```

Этот метод предназначен только для оптимизации производительности. Не полагайтесь на него, чтобы «предотвратить» рендер, так как это может привести к ошибкам.

!Примечание

В отличие от метода shouldComponentUpdate() для классовых компонентов, функция areEqual возвращает true, если пропсы равны, и значение false, если пропсы не равны. Это обратные значения для shouldComponentUpdate.