#### Наследование и его альтернативы

В объектно-ориентированных языках программирования существует три способа организации взаимодействия между классами.

**Наследование** 
- Класс-наследник имеет все поля и методы родительского класса, и, как правило, добавляет какой-то новый функционал или/и поля.
- Наследование описывается словом «является».

 Легковой автомобиль является автомобилем. Вполне естественно, если он будет его наследником.

```C#
{
    bool hasWheels;
}

class Car : Vehicle
{
    string model = "Porshe";
    int numberOfWheels = 4

```

*Минусы*

- Во-первых, далеко не все отношения между классами определяются отношением «является», 
- а во-вторых, наследование является самой сильной связью между двумя классами, которую невозможно разорвать во время исполнения (это отношение является статическим и, в строготипизированных языках определяется во время компиляции).

**Ассоциация**
- Это когда один класс включает в себя другой класс в качестве одного из полей. 
- Ассоциация описывается словом «имеет».
 Автомобиль имеет двигатель. Вполне естественно, что он не будет являться наследником двигателя (хотя такая архитектура тоже возможна в некоторых ситуациях).

***Выделяют два частных случая ассоциации: композицию и агрегацию.***

**Композиция**
- это когда двигатель не существует отдельно от автомобиля.
- Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.

```C#
class Engine
{
    int power;
    public Engine(int p)
    {
        power = p;
    }
}

class Car
{
    string model = "Porshe";
    Engine engine;
    public Car()
    {
        this.engine = new Engine(360);
    }
}
```


**Агрегация** 
- это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.

```C#
class Engine
{
    int power;
    public Engine(int p)
    {
       power = p;
    }
}        

class Car
{
    string model = "Porshe";
    Engine engine;
    public Car(Engine someEngine)
    {
         this.engine = someEngine;
    }
}

Engine goodEngine = new Engine(360);
Car porshe = new Car(goodEngine);

```

**Итого**
существует пять основных типов отношений:
— Ассоциация
— Агрегарция
— Композиция
и еще два типа, которые в этой статье рассматривать не будем:
— Наследования (иногда этот тип еще называют генерализацией)
— Реализация (это тип отношений базируется на интерфейсах. То есть создается интерфейсы, которые основной класс должен реализовать.)


**Композиция**, **агрегация** и **ассоциация** эти три понятия очень похожи друг на друга. Все они означают что внутри одного объекта будет существовать другой объект.

Самый простой способ понять эти термины это использовать аналогию из реального мира. Представим себе что у нас есть класс комната и есть два других класса мебель и стена. Мы можем сказать что у комнаты будет какая та мебель и какие то стены. То есть объект комната может использоваться объекты стены и мебель по мере необходимости. Но есть разница в отношения комната — стены и комната — мебель. Разница в том что стены никогда не выйдут из объекта комната. Стены не могут существовать вне комнаты. То есть стена всегда будет создаваться внутри объекта комната. Такая связь называется композиция. И эта связь будет жесткой. Зато мебель очень легко представить за пределами комнаты. Один экземпляр мебели может принадлежать с начало одной комнате потом другой. Такая связь называется ассоциацией или агрегацией. И такая связь будет более гибкой. О различие между ассоциацией или агрегацией чуть позже.

Способ реализации отношений между классами или объектами и есть основное концептуальное различие между композицией, агрегацией и ассоциацией . При композиции мы не можем что то вынести а при агрегации или ассоциации мы можем передать объект из одного объекта в другой.


- Ассоциация

Пример реализации ассоциации

```javaScript
class Logger {
  constructor() {
    this.stream = null;
  }
  log(message) {
    if (this.stream) {
      this.stream.write(message);
    }
  }
}
const logger = new Logger();
logger.stream = process.stdout;
logger.log('Here we are');

```
Тут у нас есть атрибут stream, в котором должна быть ссылка на поток который куда то будет отправлять сообщение. Метод log проверяет что в классе задан stream и использует его для отправки сообщения. То есть ассоциация это когда у одного класса есть ссылка на другой класс. Это создает большую гибкость в отношениях между классами. Например у нас есть возможность смены потока во время выполнения программы.


- Агрегация

Агрегация это тип отношений когда один объект является частью другого. Агрегация образует слабую связь между объектами. Все зависимые классы инициализируются вне основного объекта.

Пример реализации агрегации:

```javaScript
class Logger {
  constructor(stream) {
    this.stream = stream;
  }
  log(message) {
    if (this.stream) {
      this.stream.write(message);
    }
  }
}
const logger = new Logger(process.stdout);
logger.log('Here we are');

```
При агрегации у нас получается более прочная связь, чем при ассоциации. В данном случае связь образуется при создание экземпляра класса Logger, в конструктор которого мы передаем другой класс.


- Композиция

Композиция это тип отношений при котором один объект может принадлежать только другому объекту и никому другому. При композиции образуется сильная связь между объектами. При таком типе отношений основной объект полностью обеспечивает жизненный цикл объектов от которых он зависит. Используем еще один пример из реальной жизни. Возьмем машину и двигатель. Машина и двигатель конечно могут существовать друг без друга, но суть не в этом. А в том что при конкретной реализации рабочей машины, один двигатель может принадлежать только одной машине, поэтому для такой связи логично использовать композицию.

Пример реализации композиции

```javaScript
const fs = require('fs')
class Logger {
  constructor(name) {
    this.stream = fs.createWriteStream(name);
  }
  log(message) {
    this.stream.write(message);
  }
}
const logger = new Logger('file.log');

```
При агрегации у нас получается более прочная связь, чем при ассоциации. В данном случае связь образуется при создание экземпляра класса Logger, в конструктор которого мы передаем другой класс.



В данном случае внутри конструктора создается экземпляр другого класса. При этом создается более крепкая связанность этих двух классов. То есть класс Logger обязательно знает что существует библиотека fs, у него есть класс fs и у него есть метод createWriteStream и т. д. Он полностью знает реализацию другого класса.

То есть в ассоциации и агрегации предполагалось что эти два класса создается независимо, а потом связываются ссылками, в композиции они создается вместе в момент вызова конструктора.




